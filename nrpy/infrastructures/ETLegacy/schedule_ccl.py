from typing import Dict, List, Optional, Tuple
from pathlib import Path

import nrpy.grid as gri
import nrpy.c_function as cfc


class ScheduleCCL:
    """
    Class representing a ScheduleCCL object.
    """

    def __init__(
        self,
        function_name: str,
        bin: str,
        entry: str,
    ) -> None:
        """
        Initialize a ScheduleCCL object.

        :param entry: The scheduling entry.
        """
        self.function_name = function_name
        self.bin = bin
        self.entry = entry
        self.has_been_output = False


def construct_schedule_ccl(
    project_dir: str,
    thorn_name: str,
    STORAGE: str,
    extra_schedule_bins_entries: Optional[List[Tuple[str, str]]] = None,
) -> None:
    """
    Construct the ScheduleCCL string based on its properties.

    :return: The constructed ScheduleCCL string.
    """
    outstr = """# This schedule.ccl file was automatically generated by NRPy+.
#   You are advised against modifying it directly; instead
#   modify the Python code that generates it.
"""
    outstr += f"""\n##################################################
# Step 0: Allocate memory for gridfunctions, using the STORAGE: keyword.
{STORAGE}
"""
    schedule_ccl_dict: Dict[str, List[ScheduleCCL]] = {}
    for function_name, item in cfc.CFunction_dict.items():
        if item.ET_schedule_bins_entries:
            for bin, entry in item.ET_schedule_bins_entries:
                schedule_ccl_dict.setdefault(item.ET_thorn_name, []).append(
                    ScheduleCCL(function_name=function_name, bin=bin, entry=entry)
                )
        else:
            print(
                f"Warning: No schedule.ccl information (ET_schedule_bins_entries) included for: {function_name}."
            )
    if extra_schedule_bins_entries:
        for bin, entry in extra_schedule_bins_entries:
            schedule_ccl_dict[thorn_name] += [
                ScheduleCCL(function_name="", bin=bin, entry=entry)
            ]

    step = 1
    for bin in [
        "STARTUP",
        "Driver_BoundarySelect",
        "BASEGRID",
        "CCTK_INITIAL",
        "MoL_Register",
        "MoL_CalcRHS",
        "MoL_PostStep",
        "MoL_PseudoEvolution",
    ]:
        already_output_header = False
        for item in schedule_ccl_dict[thorn_name]:
            if item.bin.upper() == bin.upper() and not item.has_been_output:
                if not already_output_header:
                    outstr += f"""\n##################################################
# Step {step}: Schedule functions in the {bin} scheduling bin.
"""
                    already_output_header = True
                    step += 1
                outstr += item.entry.replace("FUNC_NAME", item.function_name)
                item.has_been_output = True

    for item in schedule_ccl_dict[thorn_name]:
        if not item.has_been_output:
            outstr += f"""\n##################################################
# Step {step}: Schedule functions in the remaining scheduling bins.
"""
            outstr += item.entry.replace("FUNC_NAME", item.function_name)

    output_Path = Path(project_dir) / thorn_name
    output_Path.mkdir(parents=True, exist_ok=True)
    with open(output_Path / "schedule.ccl", "w") as file:
        file.write(outstr)


def auto_EVOL_AUXEVOL_AUX_STORAGE() -> str:
    outstr = ""
    for gfname, gf in gri.glb_gridfcs_dict.items():
        if gf.group == "EVOL":
            outstr += """
STORAGE: evol_variables[3]     # Evolution variables
STORAGE: evol_variables_rhs[1] # Variables storing right-hand-sides
"""
            break
    for gfname, gf in gri.glb_gridfcs_dict.items():
        if gf.group == "AUXEVOL":
            outstr += """
STORAGE: auxevol_variables[1]  # Single-timelevel storage of variables needed for evolutions.
"""
            break

    for gfname, gf in gri.glb_gridfcs_dict.items():
        if gf.group == "AUX":
            outstr += """
STORAGE: aux_variables[3]      # Diagnostics variables
"""
            break
    return outstr
